{
  parserClass="ros.integrate.pkt.parser.ROSPktParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="ROSPkt"
  psiImplClassSuffix="Impl"
  psiPackage="ros.integrate.pkt.psi"
  psiImplPackage="ros.integrate.pkt.psi.impl"

  elementTypeHolderClass="ros.integrate.pkt.psi.ROSPktTypes"
  elementTypeClass="ros.integrate.pkt.psi.ROSPktElementType"
  tokenTypeClass="ros.integrate.pkt.psi.ROSPktTokenType"

  psiImplUtilClass="ros.integrate.pkt.psi.impl.ROSPktPsiImplUtil"


}

rosPktFile ::= item_*

private item_ ::= (separator|field_component_|comment|CRLF)

comment ::= LINE_COMMENT {
    methods=[getAnnotationIds]
}

private type_ ::= (CUSTOM_TYPE|KEYTYPE)

separator ::= SERVICE_SEPARATOR

const ::= (NEG_OPERATOR? NUMBER | STRING) {
    methods=[getBestFit]
}

type ::= type_ (LBRACKET NUMBER? RBRACKET)? {
    mixin="ros.integrate.pkt.psi.impl.ROSPktTypeBaseImpl"
    implements="ros.integrate.pkt.psi.ROSPktTypeBase"
    methods=[isComplete]
}

// fragments are like their parallels, but they are missing certain things from them, and therefore cannot be complete.
type_frag ::= type_ (LBRACKET NUMBER? RBRACKET?)? {
    mixin="ros.integrate.pkt.psi.impl.ROSPktTypeBaseImpl"
    implements="ros.integrate.pkt.psi.ROSPktTypeBase"
}

label ::= NAME {
    mixin="ros.integrate.pkt.psi.impl.ROSPktIdentifierImpl"
    implements="ros.integrate.pkt.psi.ROSPktIdentifier"
    methods=[set getName]
}

private field_component_ ::= (field_const|field_frag_const|field|field_frag)

field ::= type label {
    mixin="ros.integrate.pkt.psi.impl.ROSPktFieldBaseImpl"
    implements="ros.integrate.pkt.psi.ROSPktFieldBase"
    methods=[getTypeBase isComplete]
}

field_const ::= type label CONST_ASSIGNER const {
    elementType="field"
}

field_frag ::= (type|type_frag) {
    mixin="ros.integrate.pkt.psi.impl.ROSPktFieldBaseImpl"
    implements="ros.integrate.pkt.psi.ROSPktFieldBase"
    methods=[getTypeBase]
}

/*
    long fragment. Note the (CONST_ASSIGNER | const) part.
    why isn't it "CONST_ASSIGNER? const?"?
    in the above scenario, if both are present, we get a valid long field, which is already covered.
    also, its not a fragment then...
    if both are missing, we again get a valid field, this time short. If we allow this one to cover it,
    it will hide the valid field type.
    Thus, we get sort of an XOR left, which is what we have left.
 */
field_frag_const ::= (type|type_frag) label (CONST_ASSIGNER | const) {
    elementType="field_frag"
}